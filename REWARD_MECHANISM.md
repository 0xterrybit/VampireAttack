# 治理代币奖励机制详解

## 奖励机制概述

我们的吸血鬼攻击合约采用了类似 SushiSwap 的流动性挖矿奖励机制，用户通过迁移 LP 代币可以获得治理代币奖励。

## 奖励参数

```solidity
// 基础奖励：每个区块 1 GT
uint256 public constant REWARD_PER_BLOCK = 1e18;

// 创建新池子奖励：5 GT
uint256 public constant PAIR_CREATION_BONUS = 5e18;

// 计算精度
uint256 public constant REWARD_PRECISION = 1e12;
```

## 奖励计算公式

### 1. 累积每股奖励 (accRewardPerShare)

```
新的 accRewardPerShare = 当前 accRewardPerShare + (区块数 × 每区块奖励 × 精度) / 池子总量
```

### 2. 用户待领取奖励

```
待领取奖励 = (用户LP数量 × accRewardPerShare) / 精度 - 用户奖励债务
```

### 3. 奖励债务更新

```
新的奖励债务 = (用户LP数量 × accRewardPerShare) / 精度
```

## 具体计算示例

### 示例 1：单用户挖矿

**初始状态：**
- 池子总量：0
- accRewardPerShare：0
- 当前区块：1000

**用户 A 迁移 1000 LP：**
1. 更新池子（无奖励，因为总量为0）
2. 用户奖励：0（首次迁移无奖励）
3. 更新用户信息：
   - 用户LP：1000
   - 奖励债务：0
   - 池子总量：1000

**10个区块后（区块1010），用户A领取奖励：**
1. 更新池子：
   ```
   区块数 = 1010 - 1000 = 10
   奖励 = 10 × 1e18 = 10 GT
   accRewardPerShare = 0 + (10 × 1e18 × 1e12) / 1000 = 1e13
   ```

2. 计算用户奖励：
   ```
   待领取 = (1000 × 1e13) / 1e12 - 0 = 10 GT
   ```

3. 更新奖励债务：
   ```
   新债务 = (1000 × 1e13) / 1e12 = 10 GT
   ```

**结果：用户A获得 10 GT**

### 示例 2：多用户挖矿

**继续上面的状态（区块1010）：**
- 池子总量：1000
- accRewardPerShare：1e13
- 用户A已领取10 GT

**用户 B 迁移 2000 LP：**
1. 更新池子（区块未变化，无新奖励）
2. 用户B奖励：0（首次迁移）
3. 更新用户B信息：
   - 用户B LP：2000
   - 奖励债务：(2000 × 1e13) / 1e12 = 20 GT
   - 池子总量：3000

**5个区块后（区块1015），两用户同时领取：**

1. 更新池子：
   ```
   区块数 = 1015 - 1010 = 5
   奖励 = 5 × 1e18 = 5 GT
   accRewardPerShare = 1e13 + (5 × 1e18 × 1e12) / 3000 = 1e13 + 1.67e12 = 1.167e13
   ```

2. 用户A奖励：
   ```
   待领取 = (1000 × 1.167e13) / 1e12 - 10 = 11.67 - 10 = 1.67 GT
   ```

3. 用户B奖励：
   ```
   待领取 = (2000 × 1.167e13) / 1e12 - 20 = 23.34 - 20 = 3.34 GT
   ```

**结果：用户A获得1.67 GT，用户B获得3.34 GT，总计5 GT（正好等于5个区块的奖励）**

### 示例 3：创建新池子奖励

**用户C迁移一个全新的代币对：**

1. 系统检测到目标工厂中不存在该代币对
2. 自动创建新池子
3. 用户C立即获得创建奖励：**5 GT**
4. 然后按正常流程处理迁移奖励

## 奖励分配特点

### 1. 按比例分配
用户获得的奖励与其LP占比成正比：
```
用户奖励比例 = 用户LP数量 / 池子总LP数量
```

### 2. 时间加权
越早参与的用户，在相同LP数量下获得更多奖励。

### 3. 复利效应
用户可以随时领取奖励，不影响继续挖矿。

### 4. 无损失退出
用户可以随时退出，已产生的奖励不会丢失。

## 实际代码验证

我们创建了专门的测试文件 `test/RewardCalculation.t.sol` 来验证奖励计算的准确性：

### 测试结果

```bash
forge test --match-contract RewardCalculationTest -vv
```

所有4个测试均通过：

1. **单用户奖励测试** (`testSingleUserReward`)
   - 验证单用户挖矿10个区块获得10 GT奖励
   - 验证创建新池子获得5 GT奖励
   - 总计：15 GT

2. **多用户奖励分配测试** (`testMultiUserReward`)
   - 用户A独享10个区块：10 GT
   - 用户A在后6个区块中占1/3：2 GT
   - 用户B在后6个区块中占2/3：4 GT
   - 总计：16 GT（符合16个区块的总奖励）

3. **新池子创建奖励测试** (`testNewPairCreationBonus`)
   - 验证创建新池子立即获得5 GT奖励

4. **复杂场景奖励计算测试** (`testComplexRewardScenario`)
   - 验证多次迁移、多用户参与的复杂场景
   - 验证奖励在迁移时立即发放的机制
   - 验证总奖励分配的准确性（允许精度误差）

### 关键发现

1. **立即发放机制**：当用户进行第二次及以后的迁移时，之前累积的奖励会立即发放，而不是等到调用 `claim()` 时才发放。

2. **精度处理**：由于Solidity的整数除法特性，在复杂的奖励分配中可能出现微小的精度误差（通常在10 wei以内），这是正常现象。

3. **创建奖励**：创建新池子的5 GT奖励是立即发放的，不计入挖矿奖励计算。
```
 